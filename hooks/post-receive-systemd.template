#!/bin/bash
set -e

# Auto-detect configuration from repository
SCRIPT_DIR="$(dirname "$0")/../../../.."

# Simple auto-detection for now
REPO_PATH="$(pwd)"
REPO_NAME="$(basename "$REPO_PATH" .git)"
APP_NAME="$REPO_NAME"
ENVIRONMENT="production"  # Default for now
BASE_DIR="/opt/gokku"
BUILD_TYPE="systemd"
LANG="go"
BUILD_PATH="./apps/trunk/cmd/voice-agent"
BUILD_WORKDIR="apps/trunk"
KEEP_RELEASES="5"

echo "==> Auto-detected config: APP=$APP_NAME, ENV=$ENVIRONMENT"

# Set derived variables
APP_DIR="$BASE_DIR/apps/$APP_NAME/$ENVIRONMENT"
REPO_DIR="$BASE_DIR/repos/$APP_NAME.git"
RELEASE_DIR="$APP_DIR/releases/$(date +%Y%m%d-%H%M%S)"
SERVICE_NAME="$APP_NAME-$ENVIRONMENT"
BINARY_NAME="$APP_NAME"
MISE_PLUGINS="__MISE_PLUGINS__"

# Source mise helpers
SCRIPT_DIR="$(dirname "$0")/../.."
if [ -f "$SCRIPT_DIR/mise-helpers.sh" ]; then
    source "$SCRIPT_DIR/mise-helpers.sh"
fi

# Auto-setup function - detects first deploy and configures everything
auto_setup_if_needed() {
    echo "-----> Checking if auto-setup is needed..."

    # Get deploy user from current context (SSH user)
    DEPLOY_USER=$(whoami)
    echo "-----> Using deploy user: $DEPLOY_USER"

    # Check if this is first deploy (no releases directory or empty)
    if [ ! -d "$APP_DIR/releases" ] || [ -z "$(ls -A "$APP_DIR/releases" 2>/dev/null)" ]; then
        echo "-----> First deploy detected, delegating to gokku deploy..."

        # Update gokku.yml from repository first
        echo "-----> Updating gokku.yml from repository..."
        mkdir -p "$SCRIPT_DIR"
        cp -f "$RELEASE_DIR/gokku.yml" "$SCRIPT_DIR/gokku.yml" 2>/dev/null || echo "No gokku.yml found"

        # Reload configuration
        source "$SCRIPT_DIR/config-loader.sh" 2>/dev/null || echo "Config loader not found"

        # Call gokku deploy locally on server (without remotes)
        echo "-----> Running: gokku deploy $APP_NAME $ENVIRONMENT"
        if command -v gokku >/dev/null 2>&1; then
            # Use direct app/env args instead of remote-based deploy
            # This works because we're running locally on the server
            echo "-----> Setting up app configuration..."
            mkdir -p "$APP_DIR"/{releases,shared}

            # Create .env file
            if [ ! -f "$APP_DIR/shared/.env" ]; then
                cat > "$APP_DIR/shared/.env" << ENV_EOF
# Environment: $ENVIRONMENT
# App: $APP_NAME
# Generated: $(date)

PORT=8080
ENV_EOF
                echo "==> Created .env file"
            fi

            # Create systemd service
            sudo tee /etc/systemd/system/$SERVICE_NAME.service > /dev/null << SERVICE_EOF
[Unit]
Description=$APP_NAME ($ENVIRONMENT)
After=network.target

[Service]
Type=simple
User=thadeu
WorkingDirectory=$APP_DIR/current
ExecStart=$APP_DIR/current/$BINARY_NAME
Restart=always
RestartSec=5

EnvironmentFile=$APP_DIR/shared/.env

[Install]
WantedBy=multi-user.target
SERVICE_EOF

            sudo systemctl daemon-reload
            sudo systemctl enable "$SERVICE_NAME"
            echo "==> Created systemd service"

            echo "-----> Local setup completed successfully"
            # Continue with normal deploy process instead of returning
        else
            echo "-----> Gokku not found locally, falling back to manual setup..."

            # Fallback to manual setup if gokku not available
            mkdir -p "$APP_DIR"/{releases,shared}
            create_basic_env_file
            create_basic_systemd_service
            echo "-----> Basic setup complete!"
        fi
    else
        echo "-----> App already configured, proceeding with normal deploy"
    fi
}

# Create .env file from gokku.yml configuration
create_env_from_config() {
    local config_file="$1"
    local app_name="$2"
    local env_name="$3"

    local env_file="$APP_DIR/shared/.env"

    echo "# Environment: $env_name" > "$env_file"
    echo "# App: $app_name" >> "$env_file"
    echo "# Generated: $(date)" >> "$env_file"
    echo "" >> "$env_file"

    # Extract default_env_vars from gokku.yml using yq or basic parsing
    if command -v yq >/dev/null 2>&1; then
        # Use yq if available
        yq eval ".apps[] | select(.name == \"$app_name\") | .environments[] | select(.name == \"$env_name\") | .default_env_vars // {} | to_entries[] | \"\(.key)=\(.value)\"" "$config_file" >> "$env_file" 2>/dev/null || true
    else
        # Basic parsing fallback - extract PORT if not set
        if ! grep -q "^PORT=" "$env_file"; then
            echo "PORT=8080" >> "$env_file"
        fi
    fi

    echo "-----> Created .env file from gokku.yml configuration"
}

# Create basic .env file when no gokku.yml is available
create_basic_env_file() {
    local env_file="$APP_DIR/shared/.env"

    cat > "$env_file" << EOF
# Environment: $ENVIRONMENT
# App: $APP_NAME
# Generated: $(date)

# Add your environment variables here
# Example:
# API_KEY=your-key-here
# DATABASE_URL=postgres://...
PORT=8080
EOF

    echo "-----> Created basic .env file"
}

# Create systemd service from gokku.yml configuration
create_systemd_service_from_config() {
    local config_file="$1"
    local app_name="$2"
    local env_name="$3"

    local service_file="/etc/systemd/system/$SERVICE_NAME.service"

    # Extract configuration values (with fallbacks)
    local restart_policy="always"
    local restart_delay="5"

    if command -v yq >/dev/null 2>&1; then
        restart_policy=$(yq eval ".apps[] | select(.name == \"$app_name\") | .deployment.restart_policy // \"always\"" "$config_file" 2>/dev/null || echo "always")
        restart_delay=$(yq eval ".apps[] | select(.name == \"$app_name\") | .deployment.restart_delay // 5" "$config_file" 2>/dev/null || echo "5")
    fi

    sudo tee "$service_file" > /dev/null << SERVICE_EOF
[Unit]
Description=$app_name ($env_name)
After=network.target

[Service]
Type=simple
User=$DEPLOY_USER
WorkingDirectory=$APP_DIR/current
ExecStart=$APP_DIR/current/$BINARY_NAME
Restart=$restart_policy
RestartSec=$restart_delay

# Load env vars from shared .env file
EnvironmentFile=$APP_DIR/shared/.env

# Security
NoNewPrivileges=true
PrivateTmp=true

[Install]
WantedBy=multi-user.target
SERVICE_EOF

    sudo systemctl daemon-reload
    sudo systemctl enable "$SERVICE_NAME"

    echo "-----> Created systemd service from gokku.yml"
}

# Create basic systemd service when no gokku.yml is available
create_basic_systemd_service() {
    local service_file="/etc/systemd/system/$SERVICE_NAME.service"

    sudo tee "$service_file" > /dev/null << SERVICE_EOF
[Unit]
Description=$APP_NAME ($ENVIRONMENT)
After=network.target

[Service]
Type=simple
User=$DEPLOY_USER
WorkingDirectory=$APP_DIR/current
ExecStart=$APP_DIR/current/$BINARY_NAME
Restart=always
RestartSec=5

# Load env vars from shared .env file
EnvironmentFile=$APP_DIR/shared/.env

# Security
NoNewPrivileges=true
PrivateTmp=true

[Install]
WantedBy=multi-user.target
SERVICE_EOF

    sudo systemctl daemon-reload
    sudo systemctl enable "$SERVICE_NAME"

    echo "-----> Created basic systemd service"
}

echo "-----> Deploying $APP_NAME to $ENVIRONMENT..."

# Run auto-setup if needed
auto_setup_if_needed

# Create release directory
mkdir -p $RELEASE_DIR

# Extract pushed code
echo "-----> Extracting code..."
GIT_WORK_TREE=$RELEASE_DIR git checkout -f __ENV_BRANCH__ 2>/dev/null || \
GIT_WORK_TREE=$RELEASE_DIR git checkout -f main 2>/dev/null || \
GIT_WORK_TREE=$RELEASE_DIR git checkout -f master

# Check for .tool-versions and setup mise if needed
if [ -f "$RELEASE_DIR/.tool-versions" ]; then
    echo "-----> Detected .tool-versions, setting up mise..."

    # Install mise if not present
    install_mise || exit 1

    # Install plugins if configured
    if [ -n "$MISE_PLUGINS" ]; then
        install_mise_plugins "$MISE_PLUGINS" || exit 1
    fi

    # Install tools from .tool-versions
    run_mise_install "$RELEASE_DIR" || exit 1

    # Activate mise for build
    activate_mise
fi

# Build application
echo "-----> Building $APP_NAME..."
cd $RELEASE_DIR/$BUILD_WORKDIR

# Verify go.mod exists
if [ ! -f "go.mod" ]; then
    echo "ERROR: go.mod not found in $BUILD_WORKDIR"
    exit 1
fi

# Build for Linux
export GOOS=__GOOS__
export GOARCH=__GOARCH__
export CGO_ENABLED=__CGO_ENABLED__

go build -o $RELEASE_DIR/$BINARY_NAME $BUILD_PATH

if [ ! -f "$RELEASE_DIR/$BINARY_NAME" ]; then
    echo "ERROR: Build failed - binary not found at $RELEASE_DIR/$BINARY_NAME"
    exit 1
fi

BINARY_SIZE=$(du -h $RELEASE_DIR/$BINARY_NAME | cut -f1)
echo "-----> Build complete ($BINARY_SIZE)"

# Link shared environment file
echo "-----> Linking environment variables..."
ln -sf $APP_DIR/shared/.env $RELEASE_DIR/.env

# Update current symlink (atomic swap)
echo "-----> Deploying..."
ln -sfn $RELEASE_DIR $APP_DIR/current

# Restart service
echo "-----> Restarting $SERVICE_NAME..."
if sudo systemctl is-active --quiet $SERVICE_NAME; then
    sudo systemctl restart $SERVICE_NAME
else
    sudo systemctl start $SERVICE_NAME
fi

# Wait and check
sleep 2

if sudo systemctl is-active --quiet $SERVICE_NAME; then
    echo "-----> Deploy successful!"
    echo "-----> App: $APP_NAME"
    echo "-----> Environment: $ENVIRONMENT"
    echo "-----> Release: $(basename $RELEASE_DIR)"
else
    echo "ERROR: Service failed to start"
    sudo journalctl -u $SERVICE_NAME -n 20 --no-pager
    exit 1
fi

# Cleanup old releases (keep last N)
echo "-----> Cleaning up old releases..."
cd $APP_DIR/releases
ls -t | tail -n +$((KEEP_RELEASES + 1)) | xargs -r rm -rf
# Execute post_deploy commands if configured
POST_DEPLOY_COMMANDS=$(get_app_post_deploy "$APP_NAME")
if [ -n "$POST_DEPLOY_COMMANDS" ]; then
    echo "-----> Running post-deploy commands..."

    # Change to app directory for proper context
    APP_DIR="/opt/gokku/apps/$APP_NAME/$ENVIRONMENT"
    cd "$APP_DIR/current" || {
        echo "ERROR: Failed to change to app directory: $APP_DIR/current"
        exit 1
    }

    while IFS= read -r cmd; do
        if [ -n "$cmd" ]; then
            echo "       Running: $cmd"
            # Execute via gokku run for proper environment and context
            if ! /usr/local/bin/gokku run "$cmd" --app "$APP_NAME" --env "$ENVIRONMENT"; then
                echo "ERROR: Post-deploy command failed: $cmd"
                exit 1
            fi
        fi
    done <<< "$POST_DEPLOY_COMMANDS"

    echo "-----> Post-deploy commands completed"
fi

echo "-----> Done"


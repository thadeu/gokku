#!/bin/bash
set -e

APP_NAME="__APP_NAME__"
ENVIRONMENT="__ENVIRONMENT__"
BASE_DIR="__BASE_DIR__"
APP_DIR="$BASE_DIR/apps/$APP_NAME/$ENVIRONMENT"
REPO_DIR="$BASE_DIR/repos/$APP_NAME.git"
RELEASE_DIR="$APP_DIR/releases/$(date +%Y%m%d-%H%M%S)"
SERVICE_NAME="$APP_NAME-$ENVIRONMENT"
BINARY_NAME="__BINARY_NAME__"
BUILD_PATH="__BUILD_PATH__"
BUILD_WORKDIR="__BUILD_WORKDIR__"
KEEP_RELEASES="__KEEP_RELEASES__"
MISE_PLUGINS="__MISE_PLUGINS__"

# Source mise helpers
SCRIPT_DIR="$(dirname "$0")/../.."
if [ -f "$SCRIPT_DIR/mise-helpers.sh" ]; then
    source "$SCRIPT_DIR/mise-helpers.sh"
fi

# Extract deploy user from git remote
get_deploy_user() {
    # Get the user from the git remote URL
    # Format: user@host:path -> extract 'user'
    local remote_url=$(git remote get-url origin 2>/dev/null || echo "")
    if [ -n "$remote_url" ]; then
        echo "$remote_url" | sed 's/@.*//'
    else
        # Fallback: try to get from current user or default
        echo "${USER:-ubuntu}"
    fi
}

# Auto-setup function - detects first deploy and configures everything
auto_setup_if_needed() {
    echo "-----> Checking if auto-setup is needed..."

    # Get deploy user from git remote
    DEPLOY_USER=$(get_deploy_user)
    echo "-----> Using deploy user: $DEPLOY_USER"

    # Check if this is first deploy (no releases directory or empty)
    if [ ! -d "$APP_DIR/releases" ] || [ -z "$(ls -A "$APP_DIR/releases" 2>/dev/null)" ]; then
        echo "-----> First deploy detected, running auto-setup..."

        # Extract code to temp directory to read gokku.yml
        TEMP_DIR="/tmp/gokku-setup-$$"
        mkdir -p "$TEMP_DIR"

        # Extract current code
        GIT_WORK_TREE="$TEMP_DIR" git checkout -f HEAD

        # Check if gokku.yml exists in the repository
        if [ -f "$TEMP_DIR/gokku.yml" ]; then
            echo "-----> Found gokku.yml, configuring from repository..."

            # Source config loader if available
            if [ -f "$SCRIPT_DIR/config-loader.sh" ]; then
                source "$SCRIPT_DIR/config-loader.sh"
            fi

            # Create directory structure
            mkdir -p "$APP_DIR"/{releases,shared}

            # Create initial .env file with defaults from gokku.yml
            create_env_from_config "$TEMP_DIR/gokku.yml" "$APP_NAME" "$ENVIRONMENT"

            # Create systemd service
            create_systemd_service_from_config "$TEMP_DIR/gokku.yml" "$APP_NAME" "$ENVIRONMENT"

            echo "-----> Auto-setup complete!"
        else
            echo "-----> No gokku.yml found, using template defaults..."

            # Create directory structure
            mkdir -p "$APP_DIR"/{releases,shared}

            # Create basic .env file
            create_basic_env_file

            # Create basic systemd service
            create_basic_systemd_service
        fi

        # Cleanup temp directory
        rm -rf "$TEMP_DIR"
    else
        echo "-----> App already configured, skipping auto-setup"
    fi
}

# Create .env file from gokku.yml configuration
create_env_from_config() {
    local config_file="$1"
    local app_name="$2"
    local env_name="$3"

    local env_file="$APP_DIR/shared/.env"

    echo "# Environment: $env_name" > "$env_file"
    echo "# App: $app_name" >> "$env_file"
    echo "# Generated: $(date)" >> "$env_file"
    echo "" >> "$env_file"

    # Extract default_env_vars from gokku.yml using yq or basic parsing
    if command -v yq >/dev/null 2>&1; then
        # Use yq if available
        yq eval ".apps[] | select(.name == \"$app_name\") | .environments[] | select(.name == \"$env_name\") | .default_env_vars // {} | to_entries[] | \"\(.key)=\(.value)\"" "$config_file" >> "$env_file" 2>/dev/null || true
    else
        # Basic parsing fallback - extract PORT if not set
        if ! grep -q "^PORT=" "$env_file"; then
            echo "PORT=8080" >> "$env_file"
        fi
    fi

    echo "-----> Created .env file from gokku.yml configuration"
}

# Create basic .env file when no gokku.yml is available
create_basic_env_file() {
    local env_file="$APP_DIR/shared/.env"

    cat > "$env_file" << EOF
# Environment: $ENVIRONMENT
# App: $APP_NAME
# Generated: $(date)

# Add your environment variables here
# Example:
# API_KEY=your-key-here
# DATABASE_URL=postgres://...
PORT=8080
EOF

    echo "-----> Created basic .env file"
}

# Create systemd service from gokku.yml configuration
create_systemd_service_from_config() {
    local config_file="$1"
    local app_name="$2"
    local env_name="$3"

    local service_file="/etc/systemd/system/$SERVICE_NAME.service"

    # Extract configuration values (with fallbacks)
    local restart_policy="always"
    local restart_delay="5"

    if command -v yq >/dev/null 2>&1; then
        restart_policy=$(yq eval ".apps[] | select(.name == \"$app_name\") | .deployment.restart_policy // \"always\"" "$config_file" 2>/dev/null || echo "always")
        restart_delay=$(yq eval ".apps[] | select(.name == \"$app_name\") | .deployment.restart_delay // 5" "$config_file" 2>/dev/null || echo "5")
    fi

    sudo tee "$service_file" > /dev/null << SERVICE_EOF
[Unit]
Description=$app_name ($env_name)
After=network.target

[Service]
Type=simple
User=$DEPLOY_USER
WorkingDirectory=$APP_DIR/current
ExecStart=$APP_DIR/current/$BINARY_NAME
Restart=$restart_policy
RestartSec=$restart_delay

# Load env vars from shared .env file
EnvironmentFile=$APP_DIR/shared/.env

# Security
NoNewPrivileges=true
PrivateTmp=true

[Install]
WantedBy=multi-user.target
SERVICE_EOF

    sudo systemctl daemon-reload
    sudo systemctl enable "$SERVICE_NAME"

    echo "-----> Created systemd service from gokku.yml"
}

# Create basic systemd service when no gokku.yml is available
create_basic_systemd_service() {
    local service_file="/etc/systemd/system/$SERVICE_NAME.service"

    sudo tee "$service_file" > /dev/null << SERVICE_EOF
[Unit]
Description=$APP_NAME ($ENVIRONMENT)
After=network.target

[Service]
Type=simple
User=$DEPLOY_USER
WorkingDirectory=$APP_DIR/current
ExecStart=$APP_DIR/current/$BINARY_NAME
Restart=always
RestartSec=5

# Load env vars from shared .env file
EnvironmentFile=$APP_DIR/shared/.env

# Security
NoNewPrivileges=true
PrivateTmp=true

[Install]
WantedBy=multi-user.target
SERVICE_EOF

    sudo systemctl daemon-reload
    sudo systemctl enable "$SERVICE_NAME"

    echo "-----> Created basic systemd service"
}

echo "-----> Deploying $APP_NAME to $ENVIRONMENT..."

# Run auto-setup if needed
auto_setup_if_needed

# Create release directory
mkdir -p $RELEASE_DIR

# Extract pushed code
echo "-----> Extracting code..."
GIT_WORK_TREE=$RELEASE_DIR git checkout -f __ENV_BRANCH__ 2>/dev/null || \
GIT_WORK_TREE=$RELEASE_DIR git checkout -f main 2>/dev/null || \
GIT_WORK_TREE=$RELEASE_DIR git checkout -f master

# Check for .tool-versions and setup mise if needed
if [ -f "$RELEASE_DIR/.tool-versions" ]; then
    echo "-----> Detected .tool-versions, setting up mise..."

    # Install mise if not present
    install_mise || exit 1

    # Install plugins if configured
    if [ -n "$MISE_PLUGINS" ]; then
        install_mise_plugins "$MISE_PLUGINS" || exit 1
    fi

    # Install tools from .tool-versions
    run_mise_install "$RELEASE_DIR" || exit 1

    # Activate mise for build
    activate_mise
fi

# Build application
echo "-----> Building $APP_NAME..."
cd $RELEASE_DIR/$BUILD_WORKDIR

# Verify go.mod exists
if [ ! -f "go.mod" ]; then
    echo "ERROR: go.mod not found in $BUILD_WORKDIR"
    exit 1
fi

# Build for Linux
export GOOS=__GOOS__
export GOARCH=__GOARCH__
export CGO_ENABLED=__CGO_ENABLED__

go build -o $RELEASE_DIR/$BINARY_NAME $BUILD_PATH

if [ ! -f "$RELEASE_DIR/$BINARY_NAME" ]; then
    echo "ERROR: Build failed - binary not found at $RELEASE_DIR/$BINARY_NAME"
    exit 1
fi

BINARY_SIZE=$(du -h $RELEASE_DIR/$BINARY_NAME | cut -f1)
echo "-----> Build complete ($BINARY_SIZE)"

# Link shared environment file
echo "-----> Linking environment variables..."
ln -sf $APP_DIR/shared/.env $RELEASE_DIR/.env

# Update current symlink (atomic swap)
echo "-----> Deploying..."
ln -sfn $RELEASE_DIR $APP_DIR/current

# Restart service
echo "-----> Restarting $SERVICE_NAME..."
if sudo systemctl is-active --quiet $SERVICE_NAME; then
    sudo systemctl restart $SERVICE_NAME
else
    sudo systemctl start $SERVICE_NAME
fi

# Wait and check
sleep 2

if sudo systemctl is-active --quiet $SERVICE_NAME; then
    echo "-----> Deploy successful!"
    echo "-----> App: $APP_NAME"
    echo "-----> Environment: $ENVIRONMENT"
    echo "-----> Release: $(basename $RELEASE_DIR)"
else
    echo "ERROR: Service failed to start"
    sudo journalctl -u $SERVICE_NAME -n 20 --no-pager
    exit 1
fi

# Cleanup old releases (keep last N)
echo "-----> Cleaning up old releases..."
cd $APP_DIR/releases
ls -t | tail -n +$((KEEP_RELEASES + 1)) | xargs -r rm -rf
echo "-----> Done"


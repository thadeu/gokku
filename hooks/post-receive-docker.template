#!/bin/bash
set -e

APP_NAME="__APP_NAME__"
ENVIRONMENT="__ENVIRONMENT__"
BASE_DIR="__BASE_DIR__"
APP_DIR="$BASE_DIR/apps/$APP_NAME/$ENVIRONMENT"
REPO_DIR="$BASE_DIR/repos/$APP_NAME.git"
RELEASE_DIR="$APP_DIR/releases/$(date +%Y%m%d-%H%M%S)"
RELEASE_TAG="$(date +%Y%m%d-%H%M%S)"
SERVICE_NAME="$APP_NAME-$ENVIRONMENT"
CONTAINER_NAME="$APP_NAME-$ENVIRONMENT"
LANG="__LANG__"
BUILD_PATH="__BUILD_PATH__"
ENTRYPOINT="__ENTRYPOINT__"
DOCKERFILE="__DOCKERFILE__"
KEEP_RELEASES="__KEEP_RELEASES__"
KEEP_IMAGES="__KEEP_IMAGES__"
BASE_IMAGE="__BASE_IMAGE__"
MISE_PLUGINS="__MISE_PLUGINS__"

# Source helpers
SCRIPT_DIR="$(dirname "$0")/../.."
if [ -f "$SCRIPT_DIR/mise-helpers.sh" ]; then
    source "$SCRIPT_DIR/mise-helpers.sh"
fi

if [ -f "$SCRIPT_DIR/docker-helpers.sh" ]; then
    source "$SCRIPT_DIR/docker-helpers.sh"
fi

# Extract deploy user from git remote
get_deploy_user() {
    # Get the user from the git remote URL
    # Format: user@host:path -> extract 'user'
    local remote_url=$(git remote get-url origin 2>/dev/null || echo "")
    if [ -n "$remote_url" ]; then
        echo "$remote_url" | sed 's/@.*//'
    else
        # Fallback: try to get from current user or default
        echo "${USER:-ubuntu}"
    fi
}

# Auto-setup function - detects first deploy and configures everything
auto_setup_if_needed() {
    echo "-----> Checking if auto-setup is needed..."

    # Get deploy user from git remote
    DEPLOY_USER=$(get_deploy_user)
    echo "-----> Using deploy user: $DEPLOY_USER"

    # Check if this is first deploy (no releases directory or empty)
    if [ ! -d "$APP_DIR/releases" ] || [ -z "$(ls -A "$APP_DIR/releases" 2>/dev/null)" ]; then
        echo "-----> First deploy detected, running auto-setup..."

        # Extract code to temp directory to read gokku.yml
        TEMP_DIR="/tmp/gokku-setup-$$"
        mkdir -p "$TEMP_DIR"

        # Extract current code
        GIT_WORK_TREE="$TEMP_DIR" git checkout -f HEAD

        # Check if gokku.yml exists in the repository
        if [ -f "$TEMP_DIR/gokku.yml" ]; then
            echo "-----> Found gokku.yml, configuring from repository..."

            # Source config loader if available
            if [ -f "$SCRIPT_DIR/config-loader.sh" ]; then
                source "$SCRIPT_DIR/config-loader.sh"
            fi

            # Create directory structure
            mkdir -p "$APP_DIR"/{releases,shared}

            # Create initial .env file with defaults from gokku.yml
            create_env_from_config "$TEMP_DIR/gokku.yml" "$APP_NAME" "$ENVIRONMENT"

            echo "-----> Auto-setup complete!"
        else
            echo "-----> No gokku.yml found, using template defaults..."

            # Create directory structure
            mkdir -p "$APP_DIR"/{releases,shared}

            # Create basic .env file
            create_basic_env_file

        fi

        # Cleanup temp directory
        rm -rf "$TEMP_DIR"
    else
        echo "-----> App already configured, skipping auto-setup"
    fi
}

# Create .env file from gokku.yml configuration
create_env_from_config() {
    local config_file="$1"
    local app_name="$2"
    local env_name="$3"

    local env_file="$APP_DIR/shared/.env"

    echo "# Environment: $env_name" > "$env_file"
    echo "# App: $app_name" >> "$env_file"
    echo "# Generated: $(date)" >> "$env_file"
    echo "" >> "$env_file"

    # Extract default_env_vars from gokku.yml using yq or basic parsing
    if command -v yq >/dev/null 2>&1; then
        # Use yq if available
        yq eval ".apps[] | select(.name == \"$app_name\") | .environments[] | select(.name == \"$env_name\") | .default_env_vars // {} | to_entries[] | \"\(.key)=\(.value)\"" "$config_file" >> "$env_file" 2>/dev/null || true
    else
        # Basic parsing fallback - extract PORT if not set
        if ! grep -q "^PORT=" "$env_file"; then
            echo "PORT=8080" >> "$env_file"
        fi
    fi

    echo "-----> Created .env file from gokku.yml configuration"
}

# Create basic .env file when no gokku.yml is available
create_basic_env_file() {
    local env_file="$APP_DIR/shared/.env"

    cat > "$env_file" << EOF
# Environment: $ENVIRONMENT
# App: $APP_NAME
# Generated: $(date)

# Add your environment variables here
# Example:
# API_KEY=your-key-here
# DATABASE_URL=postgres://...
PORT=8080
EOF

    echo "-----> Created basic .env file"
}

echo "-----> Deploying $APP_NAME to $ENVIRONMENT (Docker)..."

# Run auto-setup if needed
auto_setup_if_needed

# Check and install Docker if needed (all-in-one setup)
echo "-----> Checking Docker installation..."
if ! command -v docker &> /dev/null; then
    echo "-----> Docker not found, installing..."
    if [ -f "$SCRIPT_DIR/docker-helpers.sh" ]; then
        install_docker || {
            echo "ERROR: Failed to install Docker"
            exit 1
        }
        export PATH="/usr/local/bin:/usr/bin:/bin:$PATH"
    else
        echo "ERROR: docker-helpers.sh not found, please install Docker manually"
        exit 1
    fi
else
    DOCKER_VERSION=$(docker --version)
    echo "-----> Docker is installed ($DOCKER_VERSION)"
fi

# Verify Docker daemon is running
echo "-----> Verifying Docker daemon..."
if ! docker ps > /dev/null 2>&1; then
    echo "-----> Starting Docker daemon..."
    if ! sudo systemctl start docker 2>/dev/null; then
        echo "ERROR: Failed to start Docker daemon"
        exit 1
    fi
    sleep 2
fi

# Create release directory
mkdir -p $RELEASE_DIR

# Extract pushed code
echo "-----> Extracting code..."
GIT_WORK_TREE=$RELEASE_DIR git checkout -f __ENV_BRANCH__ 2>/dev/null || \
GIT_WORK_TREE=$RELEASE_DIR git checkout -f main 2>/dev/null || \
GIT_WORK_TREE=$RELEASE_DIR git checkout -f master

cd $RELEASE_DIR

# Check if Dockerfile exists
if [ -n "$DOCKERFILE" ] && [ -f "$DOCKERFILE" ]; then
    echo "-----> Using existing Dockerfile: $DOCKERFILE"
    DOCKERFILE_PATH="$DOCKERFILE"
else
    echo "-----> Generating Dockerfile for $LANG..."
    DOCKERFILE_PATH="./Dockerfile"

    # Check if .tool-versions exists - use mise-based Dockerfile
    if [ -f "$RELEASE_DIR/.tool-versions" ]; then
        echo "-----> Detected .tool-versions, generating Dockerfile with mise support..."
        generate_dockerfile_with_mise "$LANG" "$BASE_IMAGE" "$ENTRYPOINT" "$MISE_PLUGINS" "$DOCKERFILE_PATH"
        echo "-----> Dockerfile generated with mise support"
    else
        # Original Dockerfile generation
        echo "-----> Generating standard Dockerfile..."

    # Generate Dockerfile based on language
    case "$LANG" in
        go)
            cat > "$DOCKERFILE_PATH" << 'DOCKERFILE_GO'
FROM __BASE_IMAGE__ AS builder
WORKDIR /app
COPY go.mod go.sum* ./
RUN go mod download
COPY . .
RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags="-w -s" -o app __BUILD_PATH__

FROM alpine:latest
RUN apk --no-cache add ca-certificates tzdata
WORKDIR /root/
COPY --from=builder /app/app .
EXPOSE ${PORT:-8080}
CMD ["./app"]
DOCKERFILE_GO
            sed -i "s|__BASE_IMAGE__|$BASE_IMAGE|g" "$DOCKERFILE_PATH"
            sed -i "s|__BUILD_PATH__|$BUILD_PATH|g" "$DOCKERFILE_PATH"
            ;;

        python)
            cat > "$DOCKERFILE_PATH" << 'DOCKERFILE_PYTHON'
FROM __BASE_IMAGE__
WORKDIR /app
RUN apt-get update && apt-get install -y --no-install-recommends gcc && rm -rf /var/lib/apt/lists/*
COPY requirements.txt* ./
RUN if [ -f requirements.txt ]; then pip install --no-cache-dir -r requirements.txt; fi
COPY . .
EXPOSE ${PORT:-8080}
CMD ["python", "__ENTRYPOINT__"]
DOCKERFILE_PYTHON
            sed -i "s|__BASE_IMAGE__|$BASE_IMAGE|g" "$DOCKERFILE_PATH"
            sed -i "s|__ENTRYPOINT__|$ENTRYPOINT|g" "$DOCKERFILE_PATH"
            ;;

        *)
            echo "ERROR: Unsupported language: $LANG"
            exit 1
            ;;
    esac

    echo "-----> Dockerfile generated"
    fi  # End of .tool-versions check
fi  # End of Dockerfile exists check

# Build Docker image
echo "-----> Building Docker image: $APP_NAME:$RELEASE_TAG..."
if ! docker build -f "$DOCKERFILE_PATH" -t "$APP_NAME:$RELEASE_TAG" .; then
    echo "ERROR: Docker build failed"
    exit 1
fi

# Tag as latest
docker tag "$APP_NAME:$RELEASE_TAG" "$APP_NAME:latest"

IMAGE_SIZE=$(docker images "$APP_NAME:$RELEASE_TAG" --format "{{.Size}}")
echo "-----> Build complete ($IMAGE_SIZE)"

# Link shared environment file
echo "-----> Linking environment variables..."
ln -sf $APP_DIR/shared/.env $RELEASE_DIR/.env

# Update current symlink (atomic swap)
echo "-----> Deploying..."
ln -sfn $RELEASE_DIR $APP_DIR/current

# Determine deployment strategy based on ZERO_DOWNTIME env variable
# Can be set in .env: ZERO_DOWNTIME=1 (enabled) or ZERO_DOWNTIME=0 (disabled)
# Default: enabled (zero-downtime by default)
deploy_container "$APP_NAME" "$RELEASE_TAG" "$RELEASE_DIR/.env" "$RELEASE_DIR" "$SERVICE_NAME" 60 || {
    echo "ERROR: Deployment failed"
    exit 1
}

# Setup systemd service if needed
SYSTEMD_UNIT="/etc/systemd/system/${SERVICE_NAME}.service"
if [ ! -f "$SYSTEMD_UNIT" ]; then
    echo "-----> Creating systemd service: $SERVICE_NAME"

    CONTAINER_PORT=$(grep "^PORT=" "$RELEASE_DIR/.env" 2>/dev/null | cut -d= -f2 | tr -d ' ')
    CONTAINER_PORT=${CONTAINER_PORT:-8080}

    sudo tee "$SYSTEMD_UNIT" > /dev/null << UNIT_EOF
[Unit]
Description=Gokku $APP_NAME ($ENVIRONMENT) Docker Container
After=docker.service
Requires=docker.service
StartLimitIntervalSec=60
StartLimitBurst=3

[Service]
Type=simple
Restart=always
RestartSec=5
User=$(whoami)
WorkingDirectory=$APP_DIR
StandardOutput=journal
StandardError=journal

ExecStart=/usr/bin/docker start -a ${APP_NAME}-blue
ExecStop=/usr/bin/docker stop ${APP_NAME}-blue
ExecReload=/usr/bin/docker restart ${APP_NAME}-blue

[Install]
WantedBy=multi-user.target
UNIT_EOF

    sudo systemctl daemon-reload
    sudo systemctl enable $SERVICE_NAME
fi

# Ensure service is running
if ! sudo systemctl is-active --quiet $SERVICE_NAME; then
    echo "-----> Starting systemd service: $SERVICE_NAME"
    sudo systemctl start $SERVICE_NAME
    sleep 3
fi

# Verify deployment
echo "=====> Verifying Blue/Green Deployment"
if docker ps --format '{{.Names}}' | grep -q "^${APP_NAME}-blue$"; then
    CONTAINER_STATUS=$(docker inspect "${APP_NAME}-blue" --format='{{.State.Status}}')
    CONTAINER_HEALTH=$(docker inspect "${APP_NAME}-blue" --format='{{.State.Health.Status}}' 2>/dev/null || echo "running")

    echo "-----> Deploy successful (Zero-Downtime)!"
    echo "-----> App: $APP_NAME"
    echo "-----> Environment: $ENVIRONMENT"
    echo "-----> Release: $(basename $RELEASE_DIR)"
    echo "-----> Image: $APP_NAME:$RELEASE_TAG"
    echo "-----> Container: ${APP_NAME}-blue (active)"
    echo "-----> Status: $CONTAINER_STATUS"
    if [ "$CONTAINER_HEALTH" != "running" ]; then
        echo "-----> Health: $CONTAINER_HEALTH"
    fi
else
    echo "ERROR: Blue container is not running after deployment"
    if docker ps -a --format '{{.Names}}' | grep -q "^${APP_NAME}-blue$"; then
        docker logs "${APP_NAME}-blue" 2>&1 | tail -30
    fi
    exit 1
fi

# Cleanup old releases (keep last N)
echo "-----> Cleaning up old releases..."
cd $APP_DIR/releases
ls -t | tail -n +$((KEEP_RELEASES + 1)) | xargs -r rm -rf

# Cleanup old images (keep last N)
echo "-----> Cleaning up old images..."
docker images "$APP_NAME" --format "{{.Tag}}" | grep -v "^latest$" | sort -r | tail -n +$((KEEP_IMAGES + 1)) | while read tag; do
    echo "       Removing image: $APP_NAME:$tag"
    docker rmi "$APP_NAME:$tag" 2>/dev/null || true
done

echo "-----> Done"

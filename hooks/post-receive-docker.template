#!/bin/bash
set -e

APP_NAME="__APP_NAME__"
ENVIRONMENT="__ENVIRONMENT__"
BASE_DIR="__BASE_DIR__"
APP_DIR="$BASE_DIR/apps/$APP_NAME/$ENVIRONMENT"
REPO_DIR="$BASE_DIR/repos/$APP_NAME.git"
RELEASE_DIR="$APP_DIR/releases/$(date +%Y%m%d-%H%M%S)"
RELEASE_TAG="$(date +%Y%m%d-%H%M%S)"
SERVICE_NAME="$APP_NAME-$ENVIRONMENT"
CONTAINER_NAME="$APP_NAME-$ENVIRONMENT"
LANG="__LANG__"
BUILD_PATH="__BUILD_PATH__"
ENTRYPOINT="__ENTRYPOINT__"
DOCKERFILE="__DOCKERFILE__"
KEEP_RELEASES="__KEEP_RELEASES__"
KEEP_IMAGES="__KEEP_IMAGES__"
BASE_IMAGE="__BASE_IMAGE__"
MISE_PLUGINS="__MISE_PLUGINS__"

# Source helpers
SCRIPT_DIR="$(dirname "$0")/../.."
if [ -f "$SCRIPT_DIR/mise-helpers.sh" ]; then
    source "$SCRIPT_DIR/mise-helpers.sh"
fi

if [ -f "$SCRIPT_DIR/docker-helpers.sh" ]; then
    source "$SCRIPT_DIR/docker-helpers.sh"
fi

echo "-----> Deploying $APP_NAME to $ENVIRONMENT (Docker)..."

# Check and install Docker if needed (all-in-one setup)
echo "-----> Checking Docker installation..."
if ! command -v docker &> /dev/null; then
    echo "-----> Docker not found, installing..."
    if [ -f "$SCRIPT_DIR/docker-helpers.sh" ]; then
        install_docker || {
            echo "ERROR: Failed to install Docker"
            exit 1
        }
        export PATH="/usr/local/bin:/usr/bin:/bin:$PATH"
    else
        echo "ERROR: docker-helpers.sh not found, please install Docker manually"
        exit 1
    fi
else
    DOCKER_VERSION=$(docker --version)
    echo "-----> Docker is installed ($DOCKER_VERSION)"
fi

# Verify Docker daemon is running
echo "-----> Verifying Docker daemon..."
if ! docker ps > /dev/null 2>&1; then
    echo "-----> Starting Docker daemon..."
    if ! sudo systemctl start docker 2>/dev/null; then
        echo "ERROR: Failed to start Docker daemon"
        exit 1
    fi
    sleep 2
fi

# Create release directory
mkdir -p $RELEASE_DIR

# Extract pushed code
echo "-----> Extracting code..."
GIT_WORK_TREE=$RELEASE_DIR git checkout -f __ENV_BRANCH__ 2>/dev/null || \
GIT_WORK_TREE=$RELEASE_DIR git checkout -f main 2>/dev/null || \
GIT_WORK_TREE=$RELEASE_DIR git checkout -f master

cd $RELEASE_DIR

# Check if Dockerfile exists
if [ -n "$DOCKERFILE" ] && [ -f "$DOCKERFILE" ]; then
    echo "-----> Using existing Dockerfile: $DOCKERFILE"
    DOCKERFILE_PATH="$DOCKERFILE"
else
    echo "-----> Generating Dockerfile for $LANG..."
    DOCKERFILE_PATH="./Dockerfile"

    # Check if .tool-versions exists - use mise-based Dockerfile
    if [ -f "$RELEASE_DIR/.tool-versions" ]; then
        echo "-----> Detected .tool-versions, generating Dockerfile with mise support..."
        generate_dockerfile_with_mise "$LANG" "$BASE_IMAGE" "$ENTRYPOINT" "$MISE_PLUGINS" "$DOCKERFILE_PATH"
        echo "-----> Dockerfile generated with mise support"
    else
        # Original Dockerfile generation
        echo "-----> Generating standard Dockerfile..."

    # Generate Dockerfile based on language
    case "$LANG" in
        go)
            cat > "$DOCKERFILE_PATH" << 'DOCKERFILE_GO'
FROM __BASE_IMAGE__ AS builder
WORKDIR /app
COPY go.mod go.sum* ./
RUN go mod download
COPY . .
RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags="-w -s" -o app __BUILD_PATH__

FROM alpine:latest
RUN apk --no-cache add ca-certificates tzdata
WORKDIR /root/
COPY --from=builder /app/app .
EXPOSE ${PORT:-8080}
CMD ["./app"]
DOCKERFILE_GO
            sed -i "s|__BASE_IMAGE__|$BASE_IMAGE|g" "$DOCKERFILE_PATH"
            sed -i "s|__BUILD_PATH__|$BUILD_PATH|g" "$DOCKERFILE_PATH"
            ;;

        python)
            cat > "$DOCKERFILE_PATH" << 'DOCKERFILE_PYTHON'
FROM __BASE_IMAGE__
WORKDIR /app
RUN apt-get update && apt-get install -y --no-install-recommends gcc && rm -rf /var/lib/apt/lists/*
COPY requirements.txt* ./
RUN if [ -f requirements.txt ]; then pip install --no-cache-dir -r requirements.txt; fi
COPY . .
EXPOSE ${PORT:-8080}
CMD ["python", "__ENTRYPOINT__"]
DOCKERFILE_PYTHON
            sed -i "s|__BASE_IMAGE__|$BASE_IMAGE|g" "$DOCKERFILE_PATH"
            sed -i "s|__ENTRYPOINT__|$ENTRYPOINT|g" "$DOCKERFILE_PATH"
            ;;

        *)
            echo "ERROR: Unsupported language: $LANG"
            exit 1
            ;;
    esac

    echo "-----> Dockerfile generated"
    fi  # End of .tool-versions check
fi  # End of Dockerfile exists check

# Build Docker image
echo "-----> Building Docker image: $APP_NAME:$RELEASE_TAG..."
if ! docker build -f "$DOCKERFILE_PATH" -t "$APP_NAME:$RELEASE_TAG" .; then
    echo "ERROR: Docker build failed"
    exit 1
fi

# Tag as latest
docker tag "$APP_NAME:$RELEASE_TAG" "$APP_NAME:latest"

IMAGE_SIZE=$(docker images "$APP_NAME:$RELEASE_TAG" --format "{{.Size}}")
echo "-----> Build complete ($IMAGE_SIZE)"

# Link shared environment file
echo "-----> Linking environment variables..."
ln -sf $APP_DIR/shared/.env $RELEASE_DIR/.env

# Update current symlink (atomic swap)
echo "-----> Deploying..."
ln -sfn $RELEASE_DIR $APP_DIR/current

# Use Blue/Green deployment for zero-downtime updates
echo "=====> Starting Blue/Green Deployment (Zero-Downtime)"
blue_green_deploy "$APP_NAME" "$RELEASE_TAG" "$RELEASE_DIR/.env" "$RELEASE_DIR" "$SERVICE_NAME" 60 || {
    echo "ERROR: Blue/Green deployment failed"
    exit 1
}

# Setup systemd service if needed
SYSTEMD_UNIT="/etc/systemd/system/${SERVICE_NAME}.service"
if [ ! -f "$SYSTEMD_UNIT" ]; then
    echo "-----> Creating systemd service: $SERVICE_NAME"
    
    CONTAINER_PORT=$(grep "^PORT=" "$RELEASE_DIR/.env" 2>/dev/null | cut -d= -f2 | tr -d ' ')
    CONTAINER_PORT=${CONTAINER_PORT:-8080}
    
    sudo tee "$SYSTEMD_UNIT" > /dev/null << UNIT_EOF
[Unit]
Description=Gokku $APP_NAME ($ENVIRONMENT) Docker Container
After=docker.service
Requires=docker.service
StartLimitIntervalSec=60
StartLimitBurst=3

[Service]
Type=simple
Restart=always
RestartSec=5
User=$(whoami)
WorkingDirectory=$APP_DIR
StandardOutput=journal
StandardError=journal

ExecStart=/usr/bin/docker start -a ${APP_NAME}-blue
ExecStop=/usr/bin/docker stop ${APP_NAME}-blue
ExecReload=/usr/bin/docker restart ${APP_NAME}-blue

[Install]
WantedBy=multi-user.target
UNIT_EOF
    
    sudo systemctl daemon-reload
    sudo systemctl enable $SERVICE_NAME
fi

# Ensure service is running
if ! sudo systemctl is-active --quiet $SERVICE_NAME; then
    echo "-----> Starting systemd service: $SERVICE_NAME"
    sudo systemctl start $SERVICE_NAME
    sleep 3
fi

# Verify deployment
echo "=====> Verifying Blue/Green Deployment"
if docker ps --format '{{.Names}}' | grep -q "^${APP_NAME}-blue$"; then
    CONTAINER_STATUS=$(docker inspect "${APP_NAME}-blue" --format='{{.State.Status}}')
    CONTAINER_HEALTH=$(docker inspect "${APP_NAME}-blue" --format='{{.State.Health.Status}}' 2>/dev/null || echo "running")
    
    echo "-----> Deploy successful (Zero-Downtime)!"
    echo "-----> App: $APP_NAME"
    echo "-----> Environment: $ENVIRONMENT"
    echo "-----> Release: $(basename $RELEASE_DIR)"
    echo "-----> Image: $APP_NAME:$RELEASE_TAG"
    echo "-----> Container: ${APP_NAME}-blue (active)"
    echo "-----> Status: $CONTAINER_STATUS"
    if [ "$CONTAINER_HEALTH" != "running" ]; then
        echo "-----> Health: $CONTAINER_HEALTH"
    fi
else
    echo "ERROR: Blue container is not running after deployment"
    if docker ps -a --format '{{.Names}}' | grep -q "^${APP_NAME}-blue$"; then
        docker logs "${APP_NAME}-blue" 2>&1 | tail -30
    fi
    exit 1
fi

# Cleanup old releases (keep last N)
echo "-----> Cleaning up old releases..."
cd $APP_DIR/releases
ls -t | tail -n +$((KEEP_RELEASES + 1)) | xargs -r rm -rf

# Cleanup old images (keep last N)
echo "-----> Cleaning up old images..."
docker images "$APP_NAME" --format "{{.Tag}}" | grep -v "^latest$" | sort -r | tail -n +$((KEEP_IMAGES + 1)) | while read tag; do
    echo "       Removing image: $APP_NAME:$tag"
    docker rmi "$APP_NAME:$tag" 2>/dev/null || true
done

echo "-----> Done"

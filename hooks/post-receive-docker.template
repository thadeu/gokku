#!/bin/bash
set -e

APP_NAME="__APP_NAME__"
ENVIRONMENT="__ENVIRONMENT__"
BASE_DIR="__BASE_DIR__"
APP_DIR="$BASE_DIR/apps/$APP_NAME/$ENVIRONMENT"
REPO_DIR="$BASE_DIR/repos/$APP_NAME.git"
RELEASE_DIR="$APP_DIR/releases/$(date +%Y%m%d-%H%M%S)"
RELEASE_TAG="$(date +%Y%m%d-%H%M%S)"
SERVICE_NAME="$APP_NAME-$ENVIRONMENT"
CONTAINER_NAME="$APP_NAME-$ENVIRONMENT"
LANG="__LANG__"
BUILD_PATH="__BUILD_PATH__"
BUILD_WORKDIR="__BUILD_WORKDIR__"
ENTRYPOINT="__ENTRYPOINT__"
DOCKERFILE="__DOCKERFILE__"
KEEP_RELEASES="__KEEP_RELEASES__"
KEEP_IMAGES="__KEEP_IMAGES__"
BASE_IMAGE="__BASE_IMAGE__"
MISE_PLUGINS="__MISE_PLUGINS__"

# Source helpers
SCRIPT_DIR="$(dirname "$0")/../../../scripts"
if [ -f "$SCRIPT_DIR/mise-helpers.sh" ]; then
    source "$SCRIPT_DIR/mise-helpers.sh"
fi

if [ -f "$SCRIPT_DIR/docker-helpers.sh" ]; then
    source "$SCRIPT_DIR/docker-helpers.sh"
fi

# Function to generate Dockerfile for Procfile-based deployments
generate_procfile_dockerfile() {
    # Detect language from common files
    local detected_lang="generic"

    if [ -f "package.json" ]; then
        detected_lang="nodejs"
        echo "-----> Detected Node.js application"
    elif [ -f "requirements.txt" ] || [ -f "Pipfile" ] || [ -f "pyproject.toml" ]; then
        detected_lang="python"
        echo "-----> Detected Python application"
    elif [ -f "Gemfile" ]; then
        detected_lang="ruby"
        echo "-----> Detected Ruby application"
    elif [ -f "go.mod" ]; then
        detected_lang="go"
        echo "-----> Detected Go application"
    fi

    # Generate Dockerfile based on detected language
    case "$detected_lang" in
        nodejs)
            cat > Dockerfile << 'DOCKERFILE_NODEJS'
FROM node:20-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
EXPOSE ${PORT:-3000}
# Default command will be overridden by Procfile processes
CMD ["echo", "This Dockerfile is for Procfile deployment only"]
DOCKERFILE_NODEJS
            ;;

        python)
            cat > Dockerfile << 'DOCKERFILE_PYTHON'
FROM python:3.11-slim
WORKDIR /app
RUN apt-get update && apt-get install -y --no-install-recommends gcc && rm -rf /var/lib/apt/lists/*
COPY requirements*.txt ./
RUN pip install --no-cache-dir -r requirements.txt 2>/dev/null || echo "No requirements.txt found"
COPY . .
EXPOSE ${PORT:-8000}
# Default command will be overridden by Procfile processes
CMD ["echo", "This Dockerfile is for Procfile deployment only"]
DOCKERFILE_PYTHON
            ;;

        ruby)
            cat > Dockerfile << 'DOCKERFILE_RUBY'
FROM ruby:3.2-alpine
WORKDIR /app
COPY Gemfile* ./
RUN bundle install
COPY . .
EXPOSE ${PORT:-3000}
# Default command will be overridden by Procfile processes
CMD ["echo", "This Dockerfile is for Procfile deployment only"]
DOCKERFILE_RUBY
            ;;

        *)
            # Generic Dockerfile for other languages/frameworks
            cat > Dockerfile << 'DOCKERFILE_GENERIC'
FROM alpine:latest
WORKDIR /app
COPY . .
EXPOSE ${PORT:-3000}
# Default command will be overridden by Procfile processes
CMD ["echo", "This Dockerfile is for Procfile deployment only"]
DOCKERFILE_GENERIC
            ;;
    esac

    echo "-----> Dockerfile generated for $detected_lang with Procfile support"
}

# Auto-setup function - detects first deploy and configures everything
auto_setup_if_needed() {
    echo "-----> Checking if auto-setup is needed..."

    # Get deploy user from current context (SSH user)
    DEPLOY_USER=$(whoami)
    echo "-----> Using deploy user: $DEPLOY_USER"

    # Check if this is first deploy (no releases directory or empty)
    if [ ! -d "$APP_DIR/releases" ] || [ -z "$(ls -A "$APP_DIR/releases" 2>/dev/null)" ]; then
        echo "-----> First deploy detected, running auto-setup..."

        # Extract code to temp directory to read gokku.yml
        TEMP_DIR="/tmp/gokku-setup-$$"
        mkdir -p "$TEMP_DIR"

        # Extract current code
        GIT_WORK_TREE="$TEMP_DIR" git checkout -f HEAD

        # Check if gokku.yml exists in the repository
        if [ -f "$TEMP_DIR/gokku.yml" ]; then
            echo "-----> Found gokku.yml, configuring from repository..."

            # Source config loader if available
            if [ -f "$SCRIPT_DIR/config-loader.sh" ]; then
                source "$SCRIPT_DIR/config-loader.sh"
            fi

            # Create directory structure
            mkdir -p "$APP_DIR"/{releases,shared}

            # Create initial .env file with defaults from gokku.yml
            create_env_from_config "$TEMP_DIR/gokku.yml" "$APP_NAME" "$ENVIRONMENT"

            echo "-----> Auto-setup complete!"
        else
            echo "-----> No gokku.yml found, using template defaults..."

            # Create directory structure
            mkdir -p "$APP_DIR"/{releases,shared}

            # Create basic .env file
            create_basic_env_file

        fi

        # Cleanup temp directory
        rm -rf "$TEMP_DIR"
    else
        echo "-----> App already configured, skipping auto-setup"
    fi
}

# Create .env file from gokku.yml configuration
create_env_from_config() {
    local config_file="$1"
    local app_name="$2"
    local env_name="$3"

    local env_file="$APP_DIR/shared/.env"

    echo "# Environment: $env_name" > "$env_file"
    echo "# App: $app_name" >> "$env_file"
    echo "# Generated: $(date)" >> "$env_file"
    echo "" >> "$env_file"

    # Extract default_env_vars from gokku.yml using yq or basic parsing
    if command -v yq >/dev/null 2>&1; then
        # Use yq if available
        yq eval ".apps[] | select(.name == \"$app_name\") | .environments[] | select(.name == \"$env_name\") | .default_env_vars // {} | to_entries[] | \"\(.key)=\(.value)\"" "$config_file" >> "$env_file" 2>/dev/null || true
    else
        # Basic parsing fallback - extract PORT if not set
        if ! grep -q "^PORT=" "$env_file"; then
            echo "PORT=8080" >> "$env_file"
        fi
    fi

    echo "-----> Created .env file from gokku.yml configuration"
}

# Create basic .env file when no gokku.yml is available
create_basic_env_file() {
    local env_file="$APP_DIR/shared/.env"

    cat > "$env_file" << EOF
# Environment: $ENVIRONMENT
# App: $APP_NAME
# Generated: $(date)

# Add your environment variables here
# Example:
# API_KEY=your-key-here
# DATABASE_URL=postgres://...
PORT=8080
EOF

    echo "-----> Created basic .env file"
}

echo "-----> Deploying $APP_NAME to $ENVIRONMENT (Docker)..."

# Run auto-setup if needed
auto_setup_if_needed

# Check and install Docker if needed (all-in-one setup)
echo "-----> Checking Docker installation..."
if ! command -v docker &> /dev/null; then
    echo "-----> Docker not found, installing..."
    if [ -f "$SCRIPT_DIR/docker-helpers.sh" ]; then
        install_docker || {
            echo "ERROR: Failed to install Docker"
            exit 1
        }
        export PATH="/usr/local/bin:/usr/bin:/bin:$PATH"
    else
        echo "ERROR: docker-helpers.sh not found, please install Docker manually"
        exit 1
    fi
else
    DOCKER_VERSION=$(docker --version)
    echo "-----> Docker is installed ($DOCKER_VERSION)"
fi

# Verify Docker daemon is running
echo "-----> Verifying Docker daemon..."
if ! docker ps > /dev/null 2>&1; then
    echo "-----> Starting Docker daemon..."
    if ! sudo systemctl start docker 2>/dev/null; then
        echo "ERROR: Failed to start Docker daemon"
        exit 1
    fi
    sleep 2
fi

# Create release directory
mkdir -p $RELEASE_DIR

# Extract pushed code
echo "-----> Extracting code..."
GIT_WORK_TREE=$RELEASE_DIR git checkout -f __ENV_BRANCH__ 2>/dev/null || \
GIT_WORK_TREE=$RELEASE_DIR git checkout -f main 2>/dev/null || \
GIT_WORK_TREE=$RELEASE_DIR git checkout -f master

cd $RELEASE_DIR

# Determine build directory
if [ "$BUILD_WORKDIR" != "." ] && [ -n "$BUILD_WORKDIR" ]; then
    BUILD_DIR="$RELEASE_DIR/$BUILD_WORKDIR"
else
    BUILD_DIR="$RELEASE_DIR"
fi

# Check if Procfile exists - if so, force docker mode and create multiple processes
if [ -f "Procfile" ]; then
    echo "-----> Detected Procfile, enabling multi-process deployment..."
    PROC_FILE_MODE=true

    # Parse Procfile to extract process types and commands
    parse_procfile() {
        local procfile="$1"
        local -n processes_ref="$2"

        while IFS=: read -r process_type command; do
            # Skip empty lines and comments
            [[ -z "$process_type" || "$process_type" =~ ^[[:space:]]*# ]] && continue

            # Trim whitespace
            process_type=$(echo "$process_type" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            command=$(echo "$command" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

            if [ -n "$process_type" ] && [ -n "$command" ]; then
                processes_ref["$process_type"]="$command"
                echo "       Found process: $process_type -> $command"
            fi
        done < "$procfile"
    }

    # Parse the Procfile
    declare -A PROCESSES
    parse_procfile "Procfile" PROCESSES

    echo "-----> Found ${#PROCESSES[@]} process types"

    # For Procfile mode, we need to create a generic Dockerfile
    # that will be used as base for all processes
    if [ ! -f "Dockerfile" ]; then
        echo "-----> Generating Dockerfile for Procfile deployment..."
        generate_procfile_dockerfile
    else
        echo "-----> Using existing Dockerfile with Procfile processes"
    fi
else
    PROC_FILE_MODE=false
fi

# Check if Dockerfile exists
if [ -n "$DOCKERFILE" ] && [ -f "$DOCKERFILE" ]; then
    echo "-----> Using existing Dockerfile: $DOCKERFILE"
    DOCKERFILE_PATH="$DOCKERFILE"
else
    # Change to build directory
    cd "$BUILD_DIR"
    echo "-----> Generating Dockerfile for $LANG in $BUILD_DIR..."
    DOCKERFILE_PATH="./Dockerfile"

    # Check if .tool-versions exists - use mise-based Dockerfile
    if [ -f ".tool-versions" ]; then
        echo "-----> Detected .tool-versions, generating Dockerfile with mise support..."
        generate_dockerfile_with_mise "$LANG" "$BASE_IMAGE" "$ENTRYPOINT" "$MISE_PLUGINS" "$DOCKERFILE_PATH"
        echo "-----> Dockerfile generated with mise support"
    else
        # Original Dockerfile generation
        echo "-----> Generating standard Dockerfile..."

    # Generate Dockerfile based on language
    case "$LANG" in
        go)
            # Always copy from current directory when in BUILD_DIR
            COPY_SOURCE="."

            cat > "$DOCKERFILE_PATH" << DOCKERFILE_GO
FROM __BASE_IMAGE__ AS builder
COPY $COPY_SOURCE /app
WORKDIR /app
RUN go mod download
RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags="-w -s" -o app __BUILD_PATH__

FROM alpine:latest
RUN apk --no-cache add ca-certificates tzdata
WORKDIR /root/
COPY --from=builder /app/app .
EXPOSE \${PORT:-8080}
CMD ["./app"]
DOCKERFILE_GO
            ;;

        python)
            cat > "$DOCKERFILE_PATH" << 'DOCKERFILE_PYTHON'
FROM __BASE_IMAGE__
WORKDIR /app
RUN apt-get update && apt-get install -y --no-install-recommends gcc && rm -rf /var/lib/apt/lists/*
COPY requirements.txt* ./
RUN if [ -f requirements.txt ]; then pip install --no-cache-dir -r requirements.txt; fi
COPY . .
EXPOSE ${PORT:-8080}
CMD ["python", "__ENTRYPOINT__"]
DOCKERFILE_PYTHON
            sed -i "s|__BASE_IMAGE__|$BASE_IMAGE|g" "$DOCKERFILE_PATH"
            sed -i "s|__ENTRYPOINT__|$ENTRYPOINT|g" "$DOCKERFILE_PATH"
            ;;

        *)
            echo "ERROR: Unsupported language: $LANG"
            exit 1
            ;;
    esac

    echo "-----> Dockerfile generated"
    fi  # End of .tool-versions check
fi  # End of Dockerfile exists check

# Build Docker image
echo "-----> Building Docker image: $APP_NAME:$RELEASE_TAG..."
if ! docker build -f "$DOCKERFILE_PATH" -t "$APP_NAME:$RELEASE_TAG" .; then
    echo "ERROR: Docker build failed"
    exit 1
fi

# Tag as latest
docker tag "$APP_NAME:$RELEASE_TAG" "$APP_NAME:latest"

IMAGE_SIZE=$(docker images "$APP_NAME:$RELEASE_TAG" --format "{{.Size}}")
echo "-----> Build complete ($IMAGE_SIZE)"

# Link shared environment file
echo "-----> Linking environment variables..."
ln -sf $APP_DIR/shared/.env $RELEASE_DIR/.env

# Update current symlink (atomic swap)
echo "-----> Deploying..."
ln -sfn $RELEASE_DIR $APP_DIR/current

# Determine deployment strategy based on ZERO_DOWNTIME env variable
# Can be set in .env: ZERO_DOWNTIME=1 (enabled) or ZERO_DOWNTIME=0 (disabled)
# Default: enabled (zero-downtime by default)
if [ "$PROC_FILE_MODE" = true ]; then
    echo "-----> Deploying Procfile processes..."

    # Deploy each process type from Procfile
    for process_type in "${!PROCESSES[@]}"; do
        process_command="${PROCESSES[$process_type]}"
        process_service_name="$APP_NAME-$ENVIRONMENT-$process_type"
        process_container_name="$APP_NAME-$ENVIRONMENT-$process_type"

        echo "-----> Deploying process: $process_type"
        echo "       Command: $process_command"

        # Build image for this specific process
        process_image_tag="$APP_NAME-$process_type:$RELEASE_TAG"
        if ! docker build -f "$DOCKERFILE_PATH" -t "$process_image_tag" .; then
            echo "ERROR: Failed to build image for process $process_type"
            exit 1
        fi

        # Tag as latest for this process
        docker tag "$process_image_tag" "$APP_NAME-$process_type:latest"

        # Deploy the container for this process
        deploy_procfile_process "$process_type" "$process_command" "$process_image_tag" "$RELEASE_DIR/.env" "$process_service_name" "$process_container_name" || {
            echo "ERROR: Failed to deploy process $process_type"
            exit 1
        }
    done
else
    # Original single-container deployment
    deploy_container "$APP_NAME" "$RELEASE_TAG" "$RELEASE_DIR/.env" "$RELEASE_DIR" "$SERVICE_NAME" 60 || {
        echo "ERROR: Deployment failed"
        exit 1
    }
fi

# Function to deploy a single Procfile process
deploy_procfile_process() {
    local process_type="$1"
    local process_command="$2"
    local image_tag="$3"
    local env_file="$4"
    local service_name="$5"
    local container_name="$6"

    # Get port for this process (web process gets main port, others get sequential)
    if [ "$process_type" = "web" ]; then
        CONTAINER_PORT=$(grep "^PORT=" "$env_file" 2>/dev/null | cut -d= -f2 | tr -d ' ')
        CONTAINER_PORT=${CONTAINER_PORT:-3000}
    else
        # For non-web processes, use a different port or no port
        CONTAINER_PORT=""
    fi

    # Stop existing container if running
    if docker ps -q -f name="$container_name" | grep -q .; then
        echo "       Stopping existing container: $container_name"
        docker stop "$container_name" >/dev/null 2>&1 || true
        docker rm "$container_name" >/dev/null 2>&1 || true
    fi

    # Start new container with the specific process command
    echo "       Starting container: $container_name"
    if [ -n "$CONTAINER_PORT" ]; then
        docker run -d --name "$container_name" \
            --env-file "$env_file" \
            -p "$CONTAINER_PORT:$CONTAINER_PORT" \
            --restart unless-stopped \
            "$image_tag" \
            sh -c "$process_command" || {
            echo "ERROR: Failed to start container for process $process_type"
            return 1
        }
    else
        docker run -d --name "$container_name" \
            --env-file "$env_file" \
            --restart unless-stopped \
            "$image_tag" \
            sh -c "$process_command" || {
            echo "ERROR: Failed to start container for process $process_type"
            return 1
        }
    fi

    echo "       Process $process_type deployed successfully"
}

# Ensure containers are running
if [ "$PROC_FILE_MODE" = true ]; then
    echo "=====> Verifying Procfile Deployment"

    # Check all Procfile processes
    all_processes_running=true
    for process_type in "${!PROCESSES[@]}"; do
        container_name="$APP_NAME-$ENVIRONMENT-$process_type"

        if docker ps --format '{{.Names}}' | grep -q "^${container_name}$"; then
            CONTAINER_STATUS=$(docker inspect "${container_name}" --format='{{.State.Status}}')
            echo "-----> Process $process_type: running ($CONTAINER_STATUS)"
        else
            echo "ERROR: Process $process_type container is not running"
            all_processes_running=false
        fi
    done

    if [ "$all_processes_running" = true ]; then
        echo "-----> Procfile deployment successful!"
        echo "-----> App: $APP_NAME"
        echo "-----> Environment: $ENVIRONMENT"
        echo "-----> Release: $(basename $RELEASE_DIR)"
        echo "-----> Processes: ${#PROCESSES[@]} (${!PROCESSES[@]})"
    else
        echo "ERROR: Some Procfile processes failed to start"
        exit 1
    fi
else
    # Verify deployment
    echo "=====> Verifying Docker Deployment"
    if docker ps --format '{{.Names}}' | grep -q "^${APP_NAME}-blue$"; then
        CONTAINER_STATUS=$(docker inspect "${APP_NAME}-blue" --format='{{.State.Status}}')
        CONTAINER_HEALTH=$(docker inspect "${APP_NAME}-blue" --format='{{.State.Health.Status}}' 2>/dev/null || echo "running")

        echo "-----> Deploy successful!"
        echo "-----> App: $APP_NAME"
        echo "-----> Environment: $ENVIRONMENT"
        echo "-----> Release: $(basename $RELEASE_DIR)"
        echo "-----> Image: $APP_NAME:$RELEASE_TAG"
        echo "-----> Container: ${APP_NAME}-blue (active)"
        echo "-----> Status: $CONTAINER_STATUS"
        if [ "$CONTAINER_HEALTH" != "running" ]; then
            echo "-----> Health: $CONTAINER_HEALTH"
        fi
    else
        echo "ERROR: Container is not running after deployment"
        if docker ps -a --format '{{.Names}}' | grep -q "^${APP_NAME}-blue$"; then
            docker logs "${APP_NAME}-blue" 2>&1 | tail -30
        fi
        exit 1
    fi
fi

# Cleanup old releases (keep last N)
echo "-----> Cleaning up old releases..."
cd $APP_DIR/releases
ls -t | tail -n +$((KEEP_RELEASES + 1)) | xargs -r rm -rf

# Cleanup old images (keep last N)
echo "-----> Cleaning up old images..."
docker images "$APP_NAME" --format "{{.Tag}}" | grep -v "^latest$" | sort -r | tail -n +$((KEEP_IMAGES + 1)) | while read tag; do
    echo "       Removing image: $APP_NAME:$tag"
    docker rmi "$APP_NAME:$tag" 2>/dev/null || true
done

# Execute post_deploy commands if configured
POST_DEPLOY_COMMANDS=$(get_app_post_deploy "$APP_NAME")
if [ -n "$POST_DEPLOY_COMMANDS" ]; then
    echo "-----> Running post-deploy commands..."

    # Change to app directory for proper context
    APP_DIR="/opt/gokku/apps/$APP_NAME/$ENVIRONMENT"
    cd "$APP_DIR/current" || {
        echo "ERROR: Failed to change to app directory: $APP_DIR/current"
        exit 1
    }

    while IFS= read -r cmd; do
        if [ -n "$cmd" ]; then
            echo "       Running: $cmd"
            # Execute via gokku run for proper environment and context
            if ! /usr/local/bin/gokku run "$cmd" --app "$APP_NAME" --env "$ENVIRONMENT"; then
                echo "ERROR: Post-deploy command failed: $cmd"
                exit 1
            fi
        fi
    done <<< "$POST_DEPLOY_COMMANDS"

    echo "-----> Post-deploy commands completed"
fi

echo "-----> Done"

#!/bin/bash
set -e

APP_NAME="__APP_NAME__"
ENVIRONMENT="__ENVIRONMENT__"
BASE_DIR="__BASE_DIR__"
APP_DIR="$BASE_DIR/apps/$APP_NAME/$ENVIRONMENT"
REPO_DIR="$BASE_DIR/repos/$APP_NAME.git"
RELEASE_DIR="$APP_DIR/releases/$(date +%Y%m%d-%H%M%S)"
RELEASE_TAG="$(date +%Y%m%d-%H%M%S)"
SERVICE_NAME="$APP_NAME-$ENVIRONMENT"
CONTAINER_NAME="$APP_NAME-$ENVIRONMENT"
LANG="__LANG__"
BUILD_PATH="__BUILD_PATH__"
ENTRYPOINT="__ENTRYPOINT__"
DOCKERFILE="__DOCKERFILE__"
KEEP_RELEASES="__KEEP_RELEASES__"
KEEP_IMAGES="__KEEP_IMAGES__"
BASE_IMAGE="__BASE_IMAGE__"
MISE_PLUGINS="__MISE_PLUGINS__"

# Source mise helpers
SCRIPT_DIR="$(dirname "$0")/../.."
if [ -f "$SCRIPT_DIR/mise-helpers.sh" ]; then
    source "$SCRIPT_DIR/mise-helpers.sh"
fi

echo "-----> Deploying $APP_NAME to $ENVIRONMENT (Docker)..."

# Create release directory
mkdir -p $RELEASE_DIR

# Extract pushed code
echo "-----> Extracting code..."
GIT_WORK_TREE=$RELEASE_DIR git checkout -f __ENV_BRANCH__ 2>/dev/null || \
GIT_WORK_TREE=$RELEASE_DIR git checkout -f main 2>/dev/null || \
GIT_WORK_TREE=$RELEASE_DIR git checkout -f master

cd $RELEASE_DIR

# Check if Dockerfile exists
if [ -n "$DOCKERFILE" ] && [ -f "$DOCKERFILE" ]; then
    echo "-----> Using existing Dockerfile: $DOCKERFILE"
    DOCKERFILE_PATH="$DOCKERFILE"
else
    echo "-----> Generating Dockerfile for $LANG..."
    DOCKERFILE_PATH="./Dockerfile"

    # Check if .tool-versions exists - use mise-based Dockerfile
    if [ -f "$RELEASE_DIR/.tool-versions" ]; then
        echo "-----> Detected .tool-versions, generating Dockerfile with mise support..."
        generate_dockerfile_with_mise "$LANG" "$BASE_IMAGE" "$ENTRYPOINT" "$MISE_PLUGINS" "$DOCKERFILE_PATH"
        echo "-----> Dockerfile generated with mise support"
    else
        # Original Dockerfile generation
        echo "-----> Generating standard Dockerfile..."

    # Generate Dockerfile based on language
    case "$LANG" in
        go)
            cat > "$DOCKERFILE_PATH" << 'DOCKERFILE_GO'
FROM __BASE_IMAGE__ AS builder
WORKDIR /app
COPY go.mod go.sum* ./
RUN go mod download
COPY . .
RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags="-w -s" -o app __BUILD_PATH__

FROM alpine:latest
RUN apk --no-cache add ca-certificates tzdata
WORKDIR /root/
COPY --from=builder /app/app .
EXPOSE ${PORT:-8080}
CMD ["./app"]
DOCKERFILE_GO
            sed -i "s|__BASE_IMAGE__|$BASE_IMAGE|g" "$DOCKERFILE_PATH"
            sed -i "s|__BUILD_PATH__|$BUILD_PATH|g" "$DOCKERFILE_PATH"
            ;;

        python)
            cat > "$DOCKERFILE_PATH" << 'DOCKERFILE_PYTHON'
FROM __BASE_IMAGE__
WORKDIR /app
RUN apt-get update && apt-get install -y --no-install-recommends gcc && rm -rf /var/lib/apt/lists/*
COPY requirements.txt* ./
RUN if [ -f requirements.txt ]; then pip install --no-cache-dir -r requirements.txt; fi
COPY . .
EXPOSE ${PORT:-8080}
CMD ["python", "__ENTRYPOINT__"]
DOCKERFILE_PYTHON
            sed -i "s|__BASE_IMAGE__|$BASE_IMAGE|g" "$DOCKERFILE_PATH"
            sed -i "s|__ENTRYPOINT__|$ENTRYPOINT|g" "$DOCKERFILE_PATH"
            ;;

        *)
            echo "ERROR: Unsupported language: $LANG"
            exit 1
            ;;
    esac

    echo "-----> Dockerfile generated"
    fi  # End of .tool-versions check
fi  # End of Dockerfile exists check

# Build Docker image
echo "-----> Building Docker image: $APP_NAME:$RELEASE_TAG..."
if ! docker build -f "$DOCKERFILE_PATH" -t "$APP_NAME:$RELEASE_TAG" .; then
    echo "ERROR: Docker build failed"
    exit 1
fi

# Tag as latest
docker tag "$APP_NAME:$RELEASE_TAG" "$APP_NAME:latest"

IMAGE_SIZE=$(docker images "$APP_NAME:$RELEASE_TAG" --format "{{.Size}}")
echo "-----> Build complete ($IMAGE_SIZE)"

# Link shared environment file
echo "-----> Linking environment variables..."
ln -sf $APP_DIR/shared/.env $RELEASE_DIR/.env

# Update current symlink (atomic swap)
echo "-----> Deploying..."
ln -sfn $RELEASE_DIR $APP_DIR/current

# Restart service (systemd will manage the container)
echo "-----> Restarting $SERVICE_NAME..."
if sudo systemctl is-active --quiet $SERVICE_NAME; then
    sudo systemctl restart $SERVICE_NAME
else
    sudo systemctl start $SERVICE_NAME
fi

# Wait and check
sleep 3

if sudo systemctl is-active --quiet $SERVICE_NAME; then
    # Check if container is running
    if docker ps --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
        echo "-----> Deploy successful!"
        echo "-----> App: $APP_NAME"
        echo "-----> Environment: $ENVIRONMENT"
        echo "-----> Release: $(basename $RELEASE_DIR)"
        echo "-----> Image: $APP_NAME:$RELEASE_TAG"
    else
        echo "ERROR: Container is not running"
        docker logs "$CONTAINER_NAME" 2>&1 | tail -20
        exit 1
    fi
else
    echo "ERROR: Service failed to start"
    sudo journalctl -u $SERVICE_NAME -n 20 --no-pager
    exit 1
fi

# Cleanup old releases (keep last N)
echo "-----> Cleaning up old releases..."
cd $APP_DIR/releases
ls -t | tail -n +$((KEEP_RELEASES + 1)) | xargs -r rm -rf

# Cleanup old images (keep last N)
echo "-----> Cleaning up old images..."
docker images "$APP_NAME" --format "{{.Tag}}" | grep -v "^latest$" | sort -r | tail -n +$((KEEP_IMAGES + 1)) | while read tag; do
    echo "       Removing image: $APP_NAME:$tag"
    docker rmi "$APP_NAME:$tag" 2>/dev/null || true
done

echo "-----> Done"

